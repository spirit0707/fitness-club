# Вариант 7 — Учёт и управление фитнес‑клубом

Разработайте программное обеспечение для учёта и управления фитнес‑клубом. Программа должна поддерживать создание и управление записями о клиентах, тренерах, абонементах и тренировках, а также операции добавления, редактирования, удаления, поиска и анализа данных.

## Основные требования

Ниже приведены требования к реализации. Документ организован по темам — от проектирования классов до сериализации и логирования.

---

### 1. Абстрактный класс `Member` (участник)

Требуется создать абстрактный базовый класс `Member` для всех типов участников (например, клиенты, тренеры).

Обязательные элементы:

- Абстрактный метод `get_membership_info()` — должен быть реализован в каждом подклассе.
- Общие приватные атрибуты: `member_id`, `name`, `age`, `membership_type`, `join_date`.
- Метод `__str__`, возвращающий человекочитаемое представление, например: "Участник: <name>, Тип членства: <membership_type>".
- Методы сравнения (`__lt__`, `__gt__`) для сравнения участников по возрасту или дате вступления.
- Инкапсуляция: приватные поля + геттеры/сеттеры с аннотациями типов.

---

### 2. Наследование

Создайте подклассы для конкретных типов участников:

- `Client` — дополнительный атрибут `subscription` (абонемент).
- `Trainer` — дополнительный атрибут `specialization` (специализация).

В каждом подклассе:

- Переопределить `get_membership_info()` для вывода дополнительной информации (например, "Клиент: <name>, Абонемент: <subscription>").
- Переопределить `__str__()` (например, "Тренер: <name>, Специализация: <specialization>").

---

### 3. Композиция и агрегация

Класс `GymClass` — информация о групповых тренировках.

Атрибуты:

- `class_name` — название тренировки.
- `trainer` — объект `Trainer` (агрегация/ссылка).
- `schedule` — расписание (строка или структура времени).
- `participants` — список участников (`Member`).
- `location` — объект `Location` (композиция).

Методы:

- `add_participant(member)` — добавить участника.
- `remove_participant(member_id)` — удалить участника.
- `get_participants()` — вернуть список участников.

Примечание: тренировка должна существовать независимо от участников (агрегация). Объект `Location` внедряется через композицию.

---

### 4. Интерфейсы для работы с клубом

Определите интерфейсы (абстрактные базовые классы / Protocols):

- `Bookable` — метод `book_class(member, gym_class)`.
- `Reportable` — метод `generate_report(gym_class)`.

Интерфейсы используются для явной контрактной реализации функциональности бронирования и генерации отчётов.

---

### 5. Миксины

Создайте миксины для общей функциональности:

- `LoggingMixin` — метод `log_action(message: str)` для записи действий (например, "Участник <name> записан на тренировку <class_name>").
- `NotificationMixin` — метод `send_notification(target, message: str)` (например, уведомление об отмене тренировки или окончании абонемента).

Используйте оба миксина в классах, где нужна множественная функциональность (логирование + уведомления).

---

### 6. Метаклассы

Реализуйте метакласс `MemberMeta`, который автоматически регистрирует все подклассы `Member` в реестре. Это позволит динамически создавать объекты по имени типа.

---

### 7. Фабричный метод

Класс `MemberFactory` с методом `create_member(member_type: str, **kwargs)` должен возвращать экземпляр нужного подкласса (`"client"`, `"trainer"` и т.д.). Используйте реестр из метакласса для соответствия строки типу.

---

### 8. Цепочка обязанностей (Chain of Responsibility)

Реализуйте обработку запросов на продление абонемента с использованием паттерна "цепочка обязанностей":

- `Administrator` — может одобрить продление до 1 месяца.
- `Manager` — может одобрить продление до 3 месяцев.
- `Director` — может одобрить любое продление.

Создайте связку обработчиков (Administrator → Manager → Director), которая будет последовательно передавать запрос.

---

### 9. Шаблонный метод (Template Method)

Базовый класс `BookingProcess` реализует общий алгоритм `book_class()`:

1. Проверка доступности тренировки.
2. Добавление участника в список.
3. Подтверждение записи (уведомление/логирование).

Подклассы `ClientBookingProcess` и `TrainerBookingProcess` реализуют конкретные шаги (валидации, сообщения подтверждения и т.п.).

---

### 10. Декоратор для проверки прав доступа

Декоратор `check_permissions(allowed_roles: List[str])` должен проверять, имеет ли пользователь необходимые права перед выполнением операции. При отсутствии прав выбрасывать `PermissionDeniedError`.

---

### 11. Исключения

Определите пользовательские исключения:

- `InvalidMemberError` — некорректные данные участника.
- `PermissionDeniedError` — недостаточно прав.
- `ClassFullError` — тренировка переполнена.

---

### 12. Сериализация и десериализация

Добавьте методы `to_dict()` и `from_dict()` для ключевых классов (`Member`, `Client`, `Trainer`, `GymClass`) и реализуйте сохранение/загрузку данных в JSON‑файлы.

Рекомендация: использовать `datetime.isoformat()` при сериализации дат и `datetime.fromisoformat()` при десериализации.

---

### 13. Методы сравнения

Реализуйте `__eq__`, `__lt__`, `__gt__` для сравнения участников по возрасту, дате вступления или иным критериям (укажите, какой критерий используется по умолчанию и как передать альтернативный).

---

### 14. Логирование и документация

- Настройте `logging` для записи в файл и в консоль. Предусмотрите уровни логов (INFO, WARNING, ERROR) и ротацию файлов (например, `logging.handlers.RotatingFileHandler`).
- Добавьте краткие docstrings для всех классов и методов.

---

## Пример использования (микро‑сценарий)

Ниже — упрощённый сценарий, демонстрирующий, как можно пользоваться системой:

1. Создать участников через `MemberFactory`:

	- `client = MemberFactory.create_member("client", member_id=1, name="Анна", age=28, membership_type="monthly", join_date="2025-10-01", subscription="gold")`
	- `trainer = MemberFactory.create_member("trainer", member_id=10, name="Иван", age=35, membership_type="staff", join_date="2020-01-10", specialization="yoga")`

2. Создать тренировку и назначить тренера:

	- `yoga = GymClass(class_name="Morning Yoga", trainer=trainer, schedule="Mon/Wed/Fri 08:00")`

3. Записать клиента на тренировку (через `BookingProcess`):

	- `process = ClientBookingProcess()`
	- `process.book_class(client, yoga)`

4. Сгенерировать отчёт:

	- `report = ReportGenerator.generate_report(yoga)`

5. Сохранить данные в JSON:

	- `Database.save_all("data.json")`

---

## Советы по реализации и расширению

- Разделяйте ответственность: держите модель данных, бизнес‑логику и слой хранения отдельно.
- Покройте ключевые сценарии юнит‑тестами (создание участников, бронирование, обработка ошибок).
- Сделайте API для внешнего доступа (например, FastAPI) при необходимости.
- Подумайте о валидации (pydantic/dataclasses) для проверки входных данных.

## Заключение

Эта задача демонстрирует широкий набор концепций объектно‑ориентированного дизайна: наследование, композицию, агрегацию, интерфейсы, миксины, метаклассы, фабрики и паттерны проектирования (цепочка обязанностей, шаблонный метод). В дополнение — логирование, обработка ошибок и сериализация данных.
